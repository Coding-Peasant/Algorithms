# Tree and Binary Tree

## 树（tree）
树是n（n>=0）个结点的有限集。在任意一颗非空树中：有且仅有一个特定的称为根（Root）的结点；当n>1时，其余结点可分为m（m>0）个互不相交的有限集T1，T2，… Tm，其中每一个集合本身又是一颗树，并且称为根的子树（SubTree）。
* 结点（node）：包含一个数据元素及若干指向其子树的分支。
* 度（degree）：结点拥有的子树数。
* 叶子（leaf）：度为0的结点，也成为终端结点。树的度为各结点的度的最大值。
* 孩子（child）：结点的子树的根称为该结点的孩子；该结点称为孩子的双亲（parent）。
* 兄弟（sibling）：同一个双亲的孩子之间互称为兄弟。
* 祖先（ancestor）：从根结点到该结点所经分支上的所有结点；以某结点为根的子树中的任一结点都称为该结点的子孙（descendant）。
* 层次（level）：从根开始定义，根为第一层，根的孩子为第二层。
* 堂兄弟（cousin）：其双亲在同一层的结点互为堂兄弟。
* 深度（depth）：树中结点的最大层次称为树的深度或高度。
* 有序树（ordered tree）：将树中结点的各子树看成从左到右是有次序的，则称该树为有序树；否则称为无序树（unorder tree）。
* 森林（forest）：是m（m>=0）棵互不相交的树的集合。

* 存储结构：有多种形式的存储结构来表示树，其中双亲表示法、孩子表示法、孩子兄弟表示法。
1. 双亲表示法：以一组连续空间存储树的结点，同时在每个结点中附设一个指示器指示其双亲结点在表中的位置。
```
/* 树的双亲表存储表示 */
typedef struct pTNode {    /* 结点结构 */
    dataType data;
    int parent;            /* 双亲位置域 */
}pTNode;
typedef struct {           /* 树结构 */
    pTNode nodes[MAX_TREE_SIZE];
    int r;                 /* 根的位置 */
    int n;                 /* 结点数 */
}pTree;
```
2. 孩子表示法：把每个结点的孩子结点排列起来，看成一个线性表，且以单链表作存储结构，则n个结点有n个孩子链表（叶子的孩子链表尾空表）。而n个头指针又组成一个线性表。
```
* 树的孩子链表存储表示 */
typedef struct cTNode {    /* 孩子结点 */
    int child;             /* 孩子位置域 */
    struct cTNode *next;
}child;
typedef struct {
    dataType data;
    child *firstChild;     /* 孩子链表头指针 */
}cTBox;
typedef struct {
    cTBox nodes[MAX_TREE_SIZE];
    int r;                 /* 根的位置 */
    int n;                 /* 结点数 */
}cTree;
```
3. 孩子兄弟表示法：又称二叉树表示法，或者二叉链表表示法。即以二叉链表作树的存储结构。链表中结点的两个链域分别指向该结点的第一孩子结点和下一个兄弟结点。
```
/* 树的二叉链表（孩子-兄弟）存储表示 */
typedef struct cSNode {
    dataType data;
    struct cSNode *firstChild;
    struct cSNode *nextSibling;
}cSNode, *cSTree;
```

### [B-树（balance tree）](https://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&mid=2653190965&idx=1&sn=53f78fa037386f85531832cd5322d2a0&chksm=8c9909efbbee80f90512f0c36356c31cc74c388c46388dc2317d43c8f8597298f233ca9c29e9&scene=21#wechat_redirect)
B-树是一种平衡的多路查找树，一个m阶的B-树具有如下几个特征：
1. 根结点至少有两个子女。
2. 每个中间节点都包含k-1个元素和k个孩子，其中 m/2 <= k <= m。
3. 每一个叶子节点都包含k-1个元素，其中 m/2 <= k <= m。
4. 所有的叶子结点都位于同一层。
5. 每个节点中的元素从小到大排列，节点当中k-1个元素正好是k个孩子包含的元素的值域分划。

### [B+树](https://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&mid=2653191027&idx=1&sn=4ba22e3ec8bd149f69fc0aba72e4347e&chksm=8c9909a9bbee80bfa1d8497ff0525df130414c1731b5aa5287bf16ea1cf86c8d8e6f20782184&scene=21#wechat_redirect)
B+树是基于B-树的一种变体，有着比B-树更高的查询性能。一个m阶的B+树具有如下几个特征：
1. 有k个子树的中间节点包含有k个元素（B树中是k-1个元素），每个元素不保存数据，只用来索引，所有数据都保存在叶子节点。
2. 所有的叶子结点中包含了全部元素的信息，及指向含这些元素记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。
3. 所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素。

## 二叉树（binary tree)
二叉树的每个结点至多只有两颗子树（即二叉树中不存在度大于2的结点），并且二叉树的子树有左右之分，其次序不能任意颠倒。其性质如下：

1. 在二叉树的第i层上至多有2^(i-1)个结点（i>=1）。
2. 深度为k的二叉树至多有2^(k-1)个结点（k>=1）。
3. 对任何一颗二叉树T，如果其叶子结点数为n0，度为2的结点数为n2，则n0 = n2 + 1。
4. 具有n个结点的完全二叉树的深度为[log2(n)] + 1。
5. 如果对一颗树有n个结点的完全二叉树的结点按层序编号，则对任一结点i（1<=i<=n），有
1） 若i=1，则结点i是二叉树的根，无双亲；如果i>1，则双亲PARENT(i)是结点[i/2]。
2） 若2i>n，则结点i无左孩子（结点i为叶子结点）；否则其左孩子LCHILD(i)是结点2i。
3） 若2i+1>n，则结点i无右孩子；否则其右孩子LCHILD(i)是结点2i+1。
6. 给定n个结点，能构成h(n)=C(2n,n)/(n+1)种不同的二叉树。即为卡特兰数（catalan number）的第n项，catalan数h(0)=1,h(1)=1, ...（n>=0）。

* 遍历二叉树（traversing binary tree）：如何按某条搜索路径巡访树中每个结点，使每个结点均被访问一次，而且仅被访问一次。实质上是：对一个非线性结构进行线性化操作，使每个结点在这些线性序列中有且仅有一个直接前驱和直接后继。分为两大类：深度优先遍历（depth first search）和广度优先遍历（breadth first search）。

1. 深度优先遍历：1）先序遍历（preOrderTraverse）：访问根节点；先序遍历左子树；先序遍历右子树。2）中序遍历（inOrderTraverse）：中序遍历左子树；访问根结点；中序遍历右子树。3）后序遍历（postOrderTraverse）：后序遍历左子树，后序遍历右子树；访问根结点。其时间复杂度为O(n)。
只需[先序|后序]遍历序列+中序遍历序列即可还原出二叉树的拓扑结构。

2. 广度优先遍历：层序遍历（levelOrderTraverse）是从上到下、从左到右按层次进行。其时间复杂度为O(n)。

* 存储结构：有顺序存储和链式存储两种。

1. 顺序存储结构：用一组地址连续的存储单元依次自上而下、自左至右存储完全二叉树上的结点元素，即将完全二叉树上编号为i的结点元素存储在一维数组中下标为i-1的分量中。

2. 链式存储结构：二叉链表由数据域和左、右指针域；在含有n个结点的二叉链表中有n+1个空链域。三叉链表由数据域和左、右指针域及指向其双向亲的指针域。
```
typedef char dataType;
/* linked storage structure */
typedef struct biTNode {
    dataType data;
    struct biTNode *lChild;
    struct biTNode *rChild;
} biTNode, *linkedBiTree;
```

### 满二叉树（full binary tree）
一个深度为k且有(2^k)-1个结点的二叉树称为满二叉树。深度为k的，有n个结点的二叉树，当且仅当其每个结点都与深度为k的满二叉树中编号从1至n个结点一一对应时，称为完全二叉树（complete binary tree）。

### 赫夫曼树（huffman tree）
赫夫曼树是带权路径长度最小的二叉树，又称最优树。
* 路径：从树中一个结点到另一个结点之间的分支构成这两个结点之间的路径。
* 路径长度：路径上的分支数目。
* 树的路径长度：是从树根到每一个结点的路径长度之和。
* 带权路径长度：从该结点到树根之间的路径长度与结点上权的乘积。
* 树的带权路径长度：树中所有叶子结点的带权路径长度之和。
* 前缀编码：若要设计长短不等的编码，则必须时是一个字符的编码都不是另一个字符的编码的前缀，这编码称为前缀编码。
* [赫夫曼编码（Huffman Coding）](https://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&mid=2653202633&idx=1&sn=9316701e56b5ac842ca146efdae7827e&chksm=8c99da13bbee53052de481ccabfc2a976f4a106f2ce5181ba01fb388adaf120246d9ff91c416&scene=21#wechat_redirect)：设计电文总长度最短的二进制前缀码即为以n种字符出现的频率作为权，设计一棵赫夫曼树的问题，由此得到的二进制前缀码称为赫夫曼编码。

### 二叉排序树（binary sort tree）
二叉排序树也称为二叉查找树或二叉搜索树。有如下性质：
1. 若它的左子树不空，则左子树上所有节点值均小于它的根结点的值。
2. 若它的右子树不空，则右子树上所有节点值均大于它的根结点的值。
3. 它的左、右子树也分别为二叉排序树。

### 平衡二叉树（balance binary tree）
平衡二叉树它的左子树和右子树都是平衡二叉树；且左子树和右子树的深度之差的绝对值不超过1。又称AVL树。
* 平衡因子（balance factor）：该结点的左子树深度减去它的右子树深度。因此平衡二叉树上的所有结点的平衡因子只可能是-1，0，1。只要树上有一个结点的平衡因子绝对值大于1，则该二叉树就不是平衡的。
* 旋转（rotate）：当向平衡二叉树插入一个结点后，如果有结点的平衡因子变成了±2，就必须从重新平衡以这个结点为根的子树，这个重新平衡的过程称为旋转。一般情况下，假设由于在二叉排序上插入结点而失去平衡的最小子树根节点为a，则失去平衡后进行调整的规律分为4种情况：
1. 单向右旋平衡处理：由于在a的左子树根结点的左子树上插入结点，a的平衡因子由1变为2，致使以a为根的子树失去平衡（LL），则需要进行一次向右的顺时针旋转操作，即对以a为根的子树右旋。
2. 单向左旋平衡处理：由于在a的右子树根结点的右子树上插入结点，a的平衡因子由-1变为-2，致使以a为根的子树失去平衡（RR），则需要进行一次向左的逆时针旋转操作，即对以a为根的子树左旋。
3. 双向旋转（先左后右）平衡处理：由于在a的左子树根结点的右子树插入结点，a的平衡因子由1变为2，致使以a为根的子树失去平衡（LR），则需要进行两次旋转（先左旋后右旋）操作，即先对a的左子树左旋，然后对以a为根的子树右旋。
4. 双向旋转（先右后左）平衡处理：由于在a的右子树根结点的左子树插入结点，a的平衡因子由-1变为-2，致使以a为根的子树失去平衡（RL），则需要进行两次旋转（先右旋后左旋）操作，即先对a的右子树右旋，然后对以a为根的子树左旋。


### [红黑树（red black tree)](https://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&mid=2653191832&idx=1&sn=12017161025495c6914b5ab9397baa59&chksm=8c990c42bbee8554ba02eb83d839123bd3bead6ffc736111456ea77367a3df75750cf88016e0&scene=21#wechat_redirect)
是一种自平衡二叉查找树，其特性如下：
1. 节点是红色或黑色。
2. 根节点是黑色。
3. 每个叶子节点都是黑色的空节点（NIL节点）。
4. 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)
5. 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。

## 回溯法
回溯（backtracking）法也是设计递归过程的一个重要的方法，它的求解过程实质上是一个先序遍历一颗“状态树”的过程，只是这颗树不是遍历前预先建立的，而时隐含在遍历过程中。然而很多问题用回溯和试探求解时，描述求解过程的状态树不是一颗满的多叉树。当试探过程中出现的状态和问题所求解产生矛盾时，不再继续试探下去，这时出现的叶子结点不是问题的解的终结状态。这类问题求解过程可看成时在约束条件下进行先序遍历，并在遍历过程中剪去那些不满足条件的分支。