# Sort
排序（sorting）：将一个数据元素（或记录）的任意序列，重新排列成一个按关键字有序的序列。排序分内部排序和外部排序。
* 稳定性：待排序记录记录中，存在两个或两个以上的记录具有相同的关键字，在用某种排序法排序后，若这些相同关键字的元素的相对次序仍然不变，则这种排序方法是稳定的；反之这种排序方法是不稳定的。
* 内部排序：指的是待排序记录存放在计算机随机存储器中进行的排序过程。
* 外部排序：指的是待排序记录的数量很大，以致内存一次不能容纳全部记录，在排序过尚需对外存进行访问的排序过程。

## 内部排序
内部排序的方法有很多，但就其性能而言，很难提出一种被认为是最好的方法，每一种方法都有各自的优缺点，适合在不同的环境下使用。

### 插入排序
插入排序：将有序记录从后向前扫描找到合适的位置插入未排序记录，对未排序记录从前向后扫描直至所有的记录都被排序。
* 直接插入排序（straight insert sort）：将一个记录插入到已经排好的有序表中，从而得到一个新的、记录数增加1的有序表。第i趟直接插入排序：在从a[0]到a[i-1]有序子序列中，插入一个记录a[i]后；变为从a[0]到a[i]的有序子序列。在自i-1起向前搜索过程中，可以同时向后移动记录。整个排序过程进行n-1趟插入。
* 希尔排序（shell sort）：又称缩小增量排序，是对直接插入排序的一种改进；先将整个待排序记录分割成为若干子序列分别进行直接插入排序（一趟希尔排序），待整个序列中的记录基本有序时，再对全体记录进行一次直接插入排序。特点：子序列的构成不是简单的“逐段分割”而是将相隔某个“增量”的记录组成一个子序列。

### 交换排序
交换排序：根据序列中两个键值的比较结果来对换两个记录在序列中的位置；特点：将键值较大的记录向序列的尾部移动，键值较小的记录向序列的前部移动。
* 冒泡排序（bubble sort）：第i趟冒泡排序是从a[0]到a[n-i]依次比较相邻两个记录的关键字，并在逆序时交换相邻记录（可以用一趟排序过程中没有进行交换记录的操作作为结束条件）。
* 快速排序（quick sort）：是对冒泡排序的一种改进。通过一趟排序将待排序记录分割成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。一趟快速排序的步骤：附设两个指针left和right，设枢轴记录的关键字为pivot；则首先从right所指位置起向前搜索找到第一个关键字小于pivot的记录和枢轴记录交换；然后从left所指位置起向后搜索找到第一个关键字大于pivot的记录和枢轴记录交换；重复这两步直至left=right（在排序过程中对枢轴位置的赋值是多余的，因为只有在一趟排序结束时即left=right的位置才是枢轴的最后位置）。

### 选择排序
选择排序（selection sort）：每一趟在n-i+1（i=1, 2, ... , n-1）个记录中选取关键字最小的记录作为有序序列中第i个记录。
* 简单选择排序（simple selection sort）：第i趟简单选择排序，通过n-i次关键字间的比较，从n-i+1个记录中选出关键字最小的记录，并和第i个记录交换之。
* 堆排序（heap sort）：利用堆这种数据结构所设计的一种排序算法。1）把无序数组构建成二叉堆。需要从小到大排序，则构建成最大堆；需要从大到小排序，则构建成最小堆。2）循环删除堆顶元素，替换到二叉堆的末尾，调整堆产生新的堆顶。

### 归并排序
归并排序（merging sort）：是将两个或两个以上的有序表组合成一个新的有序表，归并算法的核心思想是分治法（Divide and Conquer）。假设初始数列含有n个记录，则可以看成是n个有序的子序列，每个子序列的长度为1，然后两两归并，得到[n/2]个长度为2或1的有序子序列；再两两归并，如此重复直至得到一个长度为n的有序序列为止，这种排序方法称为2-路归并排序。整个归并操作需要进行[log2n]趟。

### 计数排序
计数排序（counting sort）：是一个非基于比较的排序算法，它的优势在于在对一定范围内的整数排序时，它的复杂度为Ο(n+k)（其中k是整数的范围），快于任何比较排序算法。

### 桶排序
桶排序（bucket sort）：可以看成是计数排序的升级版，遍历数据把其分到多个有限个对应的桶里，然后对每个非空的桶进行排序，并把每个非空桶的数据依次取出，即可完成排序。

### 基数排序
基数排序（radix sort）：不需要进行记录关键字间的比较。是一种借助多关键字排序的思想对单逻辑关键字进行排序的方法。
* 最高位优先（most significant digit first）：先对主关键字进行排序，将序列分成若干子序列，每个子序列中的记录都具有相同的关键字；然后依次对每个次关键字重复上述操作；最后将所有子序列连接在一起成为一个有序的序列。
* 最低位优先（least significant digit first）：先对次关键字进行排序，将序列分成若干子序列，每个子序列中的记录都具有相同的关键字；然后依次对每个次关键字重复上述操作；最后将所有子序列连接在一起成为一个有序的序列。

<table border="2">
    <tr>
        <td colspan="2">排序方法</td>
        <td>平均时间</td>
        <td>最好时间</td>
        <td>最坏时间</td>
        <td>空间复杂度</td>
        <td>稳定性</td>
    </tr>
    <tr>
        <td rowspan="2">插入排序</td>
        <td>直接插入排序</td>
        <td>O(n^2)</td>
        <td>O(n)</td>
        <td>O(n^2)</td>
        <td>O(1)</td>
        <td>稳定</td>
    </tr>
    <tr>
        <td>希尔排序</td>
        <td>O(nlogn)</td>
        <td>O(n(logn)^2)</td>
        <td>O(n(logn)^2)</td>
        <td>O(1)</td>
        <td>不稳定</td>
    </tr>
    <tr>
        <td rowspan="2">交换排序</td>
        <td>冒泡排序</td>
        <td>O(n^2)</td>
        <td>O(n)</td>
        <td>O(n^2)</td>
        <td>O(1)</td>
        <td>稳定</td>
    </tr>
    <tr>
        <td>快速排序</td>
        <td>O(nlogn)</td>
        <td>O(nlogn)</td>
        <td>O(n^2)</td>
        <td>O(logn)</td>
        <td>不稳定</td>
    </tr>
    <tr>
        <td rowspan="2">选择排序</td>
        <td>简单选择排序</td>
        <td>O(n^2)</td>
        <td>O(n^2)</td>
        <td>O(n^2)</td>
        <td>O(1)</td>
        <td>不稳定</td>
    </tr>
    <tr>
        <td>堆排序</td>
        <td>O(nlogn)</td>
        <td>O(nlogn)</td>
        <td>O(nlogn)</td>
        <td>O(1)</td>
        <td>不稳定</td>
    </tr>
    <tr>
        <td colspan="2">归并排序</td>
        <td>O(nlogn)</td>
        <td>O(nlogn)</td>
        <td>O(nlogn)</td>
        <td>O(n)</td>
        <td>稳定</td>
    </tr>
    <tr>
        <td colspan="2">计数排序</td>
        <td>O(n+k)</td>
        <td>O(n+k)</td>
        <td>O(n+k)</td>
        <td>O(k)</td>
        <td>稳定</td>
    </tr>
    <tr>
        <td colspan="2">桶排序</td>
        <td>O(n+k)</td>
        <td>O(n+k)</td>
        <td>O(n^2)</td>
        <td>O(n+k)</td>
        <td>稳定</td>
    </tr>
    <tr>
        <td colspan="2">基数排序</td>
        <td>O(n*k)</td>
        <td>O(n*k)</td>
        <td>O(n*k)</td>
        <td>O(n+k)</td>
        <td>稳定</td>
    </tr>
</table>

## 外部排序